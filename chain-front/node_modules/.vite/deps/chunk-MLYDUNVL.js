import {
  require_build,
  require_build2,
  require_build3,
  require_build4
} from "./chunk-VHC7IJC6.js";
import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(type, data) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    function pubkeyToAddress(type, data) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = void 0;
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    exports.fromSeconds = fromSeconds;
    exports.toSeconds = toSeconds;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    function toRfc3339WithNanoseconds(dateTime) {
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = dateTime.nanoseconds?.toString() ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = makeJsonRpcId;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
  }
});

// node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/symbol-observable/ponyfill.js"(exports, module) {
    module.exports = require_ponyfill();
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal;
  }
});

// node_modules/xstream/index.js
var require_xstream = __commonJS({
  "node_modules/xstream/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports.NO = NO;
    function noop() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      (function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      })()
    );
    var Observer = (
      /** @class */
      (function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      })()
    );
    var FromObservable = (
      /** @class */
      (function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      })()
    );
    var Merge = (
      /** @class */
      (function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var L = s.length;
          this.ac = L;
          for (var i = 0; i < L; i++)
            s[i]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s = this.insArr;
          var L = s.length;
          for (var i = 0; i < L; i++)
            s[i]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
              return;
            u._c();
          }
        };
        return Merge2;
      })()
    );
    var CombineListener = (
      /** @class */
      (function() {
        function CombineListener2(i, out, p) {
          this.i = i;
          this.out = out;
          this.p = p;
          p.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p = this.p, out = this.out;
          if (out === NO)
            return;
          if (p.up(t, this.i)) {
            var b = cp(p.vals);
            out._n(b);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p = this.p;
          if (p.out === NO)
            return;
          if (--p.Nc === 0)
            p.out._c();
        };
        return CombineListener2;
      })()
    );
    var Combine = (
      /** @class */
      (function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i) {
          var v = this.vals[i];
          var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
          this.vals[i] = t;
          return Nn === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var n = this.Nc = this.Nn = s.length;
          var vals = this.vals = new Array(n);
          if (n === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i = 0; i < n; i++) {
              vals[i] = NO;
              s[i]._add(new CombineListener(i, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s = this.insArr;
          var n = s.length;
          var ils = this.ils;
          for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      })()
    );
    var FromArray = (
      /** @class */
      (function() {
        function FromArray2(a) {
          this.type = "fromArray";
          this.a = a;
        }
        FromArray2.prototype._start = function(out) {
          var a = this.a;
          for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      })()
    );
    var FromPromise = (
      /** @class */
      (function() {
        function FromPromise2(p) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v) {
            if (prod.on) {
              out._n(v);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      })()
    );
    var Periodic = (
      /** @class */
      (function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      })()
    );
    var Debug = (
      /** @class */
      (function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var s = this.s, l = this.l;
          if (s !== noop) {
            try {
              s(t);
            } catch (e) {
              u._e(e);
            }
          } else if (l)
            console.log(l + ":", t);
          else
            console.log(t);
          u._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Debug2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Debug2;
      })()
    );
    var Drop = (
      /** @class */
      (function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          if (this.dropped++ >= this.max)
            u._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Drop2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Drop2;
      })()
    );
    var EndWhenListener = (
      /** @class */
      (function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      })()
    );
    var EndWhen = (
      /** @class */
      (function() {
        function EndWhen2(o, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      })()
    );
    var Filter = (
      /** @class */
      (function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO || !r)
            return;
          u._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Filter2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Filter2;
      })()
    );
    var FlattenListener = (
      /** @class */
      (function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      })()
    );
    var Flatten = (
      /** @class */
      (function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (!this.open && this.inner === NO)
            u._c();
        };
        Flatten2.prototype._n = function(s) {
          var u = this.out;
          if (u === NO)
            return;
          var _a = this, inner = _a.inner, il = _a.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s)._add(this.il = new FlattenListener(u, this));
        };
        Flatten2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      })()
    );
    var Fold = (
      /** @class */
      (function() {
        function Fold2(f, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(this.acc = r);
        };
        Fold2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Fold2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Fold2;
      })()
    );
    var Last = (
      /** @class */
      (function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Last2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (this.has) {
            u._n(this.val);
            u._c();
          } else
            u._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      })()
    );
    var MapOp = (
      /** @class */
      (function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(r);
        };
        MapOp2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        MapOp2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return MapOp2;
      })()
    );
    var Remember = (
      /** @class */
      (function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      })()
    );
    var ReplaceError = (
      /** @class */
      (function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return ReplaceError2;
      })()
    );
    var StartWith = (
      /** @class */
      (function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      })()
    );
    var Take = (
      /** @class */
      (function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var m = ++this.taken;
          if (m < this.max)
            u._n(t);
          else if (m === this.max) {
            u._n(t);
            u._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Take2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Take2;
      })()
    );
    var Stream = (
      /** @class */
      (function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a = this._ils;
          var L = a.length;
          if (this._d)
            this._dl._n(t);
          if (L == 1)
            a[0]._n(t);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L == 1)
            a[0]._e(err);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._e(err);
          }
          if (!this._d && L == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L == 1)
            a[0]._c();
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a = this._ils;
          var i = a.indexOf(il);
          if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x, trace) {
          if (trace.indexOf(x) !== -1)
            return true;
          else if (x.out === this)
            return true;
          else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
          else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
              if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop, _stop: noop });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s = this.map(function() {
            return projectedValue;
          });
          var op = s._prod;
          op.type = "mapTo";
          return s;
        };
        Stream2.prototype.filter = function(passes) {
          var p = this._prod;
          if (p instanceof Filter)
            return new Stream2(new Filter(and(p.f, passes), p.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      })()
    );
    exports.Stream = Stream;
    var MemoryStream = (
      /** @class */
      (function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x) {
          this._v = x;
          this._has = true;
          _super.prototype._n.call(this, x);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      })(Stream)
    );
    exports.MemoryStream = MemoryStream;
    var xs = Stream;
    exports.default = xs;
  }
});

// node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "node_modules/@cosmjs/stream/build/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = concat;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
  }
});

// node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      get value() {
        return this.internalValue;
      }
      callbacks;
      internalValue;
      listener;
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = dropDuplicates;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
  }
});

// node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "node_modules/@cosmjs/stream/build/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromListPromise = fromListPromise;
    exports.toListPromise = toListPromise;
    exports.firstEvent = firstEvent;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => {
            listener.error(error);
          });
        },
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(new Error(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`));
          },
          error: (error) => {
            reject(error);
          }
        });
      });
    }
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
  }
});

// node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reducer = void 0;
    exports.countStream = countStream;
    exports.asArray = asArray;
    exports.lastValue = lastValue;
    var Reducer = class {
      stream;
      reducer;
      state;
      // completed maintains state of stream, resolves/rejects
      // on complete or error
      completed;
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
  }
});

// node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      updates;
      get value() {
        return this.producer.value;
      }
      producer;
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => {
                  subscription.unsubscribe();
                }, 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject(new Error("Update stream completed without expected value"));
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// node_modules/@cosmjs/stream/build/index.js
var require_build5 = __commonJS({
  "node_modules/@cosmjs/stream/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// node_modules/@cosmjs/json-rpc/build/types.js
var require_types = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = void 0;
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build5();
    var types_1 = require_types();
    var JsonRpcClient = class {
      connection;
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    function isJsonCompatibleDictionary(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      return Object.values(value).every(isJsonCompatibleValue);
    }
  }
});

// node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcId = parseJsonRpcId;
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    function parseJsonRpcRequest(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (typeof data.jsonrpc !== "string") {
        throw new Error(`Invalid "jsonrpc" field. Must be a string.`);
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
      }
      const id = parseJsonRpcId(data);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data.method;
      if (typeof method !== "string") {
        throw new Error(`Invalid "method" field. Must be a string.`);
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data.params
      };
    }
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data.error)
      };
    }
    function parseJsonRpcSuccessResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    function parseJsonRpcResponse(data) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
      }
      return response;
    }
  }
});

// node_modules/@cosmjs/json-rpc/build/index.js
var require_build6 = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = http;
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request, timeout) {
      const settings = {
        method,
        body: request ? JSON.stringify(request) : void 0,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: timeout ? AbortSignal.timeout(timeout) : void 0
      };
      return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    exports.hasProtocol = hasProtocol;
    function instanceOfRpcStreamingClient(client) {
      return "listen" in client && typeof client.listen === "function";
    }
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpBatchClient = void 0;
    var json_rpc_1 = require_build6();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      url;
      headers;
      options;
      timer;
      queue = [];
      constructor(endpoint, options = {}) {
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval,
          httpTimeout: options.httpTimeout
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => {
          this.tick();
        }, options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        if (this.timer)
          clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests, this.options.httpTimeout).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports.HttpBatchClient = HttpBatchClient;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = void 0;
    var json_rpc_1 = require_build6();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      url;
      headers;
      timeout;
      constructor(endpoint, timeout) {
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timeout = timeout;
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request, this.timeout));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      connected;
      connectedResolver;
      connectedRejecter;
      socket;
      timeoutId;
      closed = false;
      url;
      messageHandler;
      errorHandler;
      openHandler;
      closeHandler;
      timeout;
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(new Error(`Connection attempt timed out after ${elapsed} ms`));
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          } else {
            this.socket.send(data);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      connected;
      events;
      eventProducerListener;
      socket;
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data) {
        return this.socket.send(data);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build5();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      connectionStatus;
      events;
      url;
      timeout;
      queue = [];
      socket;
      isProcessingQueue = false;
      eventProducerListener;
      connectionStatusProducer;
      reconnectedHandler;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => {
          this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        });
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (_error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connectionStatus;
      events;
      socket;
      eventProducerListener;
      unconnected = true;
      disconnected = false;
      timeoutIndex = 0;
      reconnectTimeout = null;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => {
                this.socket.reconnect();
              }, _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// node_modules/@cosmjs/socket/build/index.js
var require_build7 = __commonJS({
  "node_modules/@cosmjs/socket/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build6();
    var socket_1 = require_build7();
    var stream_1 = require_build5();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexpected message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      request;
      socket;
      running = false;
      subscriptions = [];
      constructor(request, socket) {
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      url;
      socket;
      /** Same events as in socket.events but in the format we need */
      jsonRpcResponseStream;
      // Lazily create streams and use the same stream when listening to the same query twice.
      //
      // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
      // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
      subscriptionStreams = /* @__PURE__ */ new Map();
      constructor(baseUrl, onError = defaultErrorHandler) {
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/jsonchecks.js
var require_jsonchecks = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/jsonchecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jCheckSet = jCheckSet;
    exports.jCheckBoolean = jCheckBoolean;
    exports.jCheckString = jCheckString;
    exports.jCheckNumber = jCheckNumber;
    exports.jCheckArray = jCheckArray;
    exports.jCheckObject = jCheckObject;
    exports.jCheckNonEmptyString = jCheckNonEmptyString;
    exports.jCheckNonZeroNumber = jCheckNonZeroNumber;
    function jCheckSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function jCheckBoolean(value) {
      jCheckSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function jCheckString(value) {
      jCheckSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function jCheckNumber(value) {
      jCheckSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function jCheckArray(value) {
      jCheckSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function jCheckObject(value) {
      jCheckSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function jCheckNonEmptyString(value) {
      jCheckString(value);
      if (value.length === 0)
        throw new Error("Value must not be empty");
      return value;
    }
    function jCheckNonZeroNumber(value) {
      jCheckNumber(value);
      if (value === 0)
        throw new Error("Value must not be zero");
      return value;
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiToSmallInt = apiToSmallInt;
    exports.apiToBigInt = apiToBigInt;
    exports.smallIntToApi = smallIntToApi;
    var math_1 = require_build3();
    var jsonchecks_1 = require_jsonchecks();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    function apiToBigInt(input) {
      (0, jsonchecks_1.jCheckString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = createJsonRpcRequest;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/encodings.js
var require_encodings = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/requests.js
var require_requests = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/requests.js
var require_requests2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag || (exports.BlockIdFlag = BlockIdFlag = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/hasher.js
var require_hasher = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/responses.js
var require_responses = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeBlockResults = decodeBlockResults;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types2();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, jsonchecks_1.jCheckString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, jsonchecks_1.jCheckString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: data.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data.block)) : void 0,
        evidence: data.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: {
          bytes: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.pub_key_bytes)),
          type: (0, jsonchecks_1.jCheckString)(data.pub_key_type)
        },
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data.finalize_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      const txResult = data.tx_result ? decodeTxData(data.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: data.signatures ? (0, jsonchecks_1.jCheckArray)(data.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        power: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.power)),
        name: data.name
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data.network),
        version: (0, jsonchecks_1.jCheckString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total))
      };
    }
    function decodeBlock(data) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, jsonchecks_1.jCheckArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/index.js
var require_adaptor = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/comet1client.js
var require_comet1client = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/comet1client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet1Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet1Client = class _Comet1Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet1Client.create(rpcClient);
      }
      /**
       * Creates a new Comet BFT client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet1Client(rpcClient);
      }
      client;
      /**
       * Use `Comet1Client.connect` or `Comet1Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet1Client = Comet1Client;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/responses.js
var require_responses2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet1/index.js
var require_comet1 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet1/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet1Client = void 0;
    var comet1client_1 = require_comet1client();
    Object.defineProperty(exports, "Comet1Client", { enumerable: true, get: function() {
      return comet1client_1.Comet1Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests3 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests4 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, jsonchecks_1.jCheckNonEmptyString)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses3 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types2();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, jsonchecks_1.jCheckString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, jsonchecks_1.jCheckString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: data.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data.block)) : void 0,
        evidence: data.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data.finalize_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      const txResult = data.tx_result ? decodeTxData(data.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: data.signatures ? (0, jsonchecks_1.jCheckArray)(data.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data.network),
        version: (0, jsonchecks_1.jCheckString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total))
      };
    }
    function decodeBlock(data) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, jsonchecks_1.jCheckArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet38Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Comet38Client = class _Comet38Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet38Client = Comet38Client;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses4 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests3();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests5 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses5 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings3 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests6 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher3 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses6 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types2();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, jsonchecks_1.jCheckString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, jsonchecks_1.jCheckString)(data.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: data.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data.block)) : void 0,
        evidence: data.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, jsonchecks_1.jCheckArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data.network),
        version: (0, jsonchecks_1.jCheckString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckNonEmptyString)(data.channels),
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total))
      };
    }
    function decodeBlock(data) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, jsonchecks_1.jCheckArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor3 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests7 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses7 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings4 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests8 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings4();
    var requests = __importStar(require_requests7());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher4 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings4();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses8 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types2();
    var encodings_1 = require_encodings4();
    var hasher_1 = require_hasher4();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, jsonchecks_1.jCheckString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, jsonchecks_1.jCheckString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: data.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data.block)) : void 0,
        evidence: data.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, jsonchecks_1.jCheckArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data.network),
        version: (0, jsonchecks_1.jCheckString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total))
      };
    }
    function decodeBlock(data) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, jsonchecks_1.jCheckArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor4 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests8();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses8();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor4();
    var requests = __importStar(require_requests7());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint37Client = Tendermint37Client;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests7();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses7();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTendermint34Client = isTendermint34Client;
    exports.isTendermint37Client = isTendermint37Client;
    exports.isComet38Client = isComet38Client;
    exports.isComet1Client = isComet1Client;
    exports.connectComet = connectComet;
    var comet1_1 = require_comet1();
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    function isComet1Client(client) {
      return client instanceof comet1_1.Comet1Client;
    }
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else if (version.startsWith("1.")) {
        tm37Client.disconnect();
        out = await comet1_1.Comet1Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build8 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.isComet1Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.Comet1Client = exports.comet1 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports.comet1 = __importStar(require_comet1());
    var comet1_1 = require_comet1();
    Object.defineProperty(exports, "Comet1Client", { enumerable: true, get: function() {
      return comet1_1.Comet1Client;
    } });
    exports.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports, "isComet1Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet1Client;
    } });
    Object.defineProperty(exports, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

export {
  require_build8 as require_build
};
//# sourceMappingURL=chunk-MLYDUNVL.js.map
