"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bip39 = exports.EnglishMnemonic = void 0;
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
class EnglishMnemonic {
    static wordlist = english_1.wordlist;
    data;
    constructor(mnemonic) {
        // throws an error if mnemonic is invalid
        const _ = (0, bip39_1.mnemonicToEntropy)(mnemonic, english_1.wordlist);
        this.data = mnemonic;
    }
    toString() {
        return this.data;
    }
}
exports.EnglishMnemonic = EnglishMnemonic;
class Bip39 {
    /**
     * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
     *
     * | Entropy            | Words |
     * |--------------------|-------|
     * | 128 bit (16 bytes) |    12 |
     * | 160 bit (20 bytes) |    15 |
     * | 192 bit (24 bytes) |    18 |
     * | 224 bit (28 bytes) |    21 |
     * | 256 bit (32 bytes) |    24 |
     *
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
     * @param entropy The entropy to be encoded. This must be cryptographically secure.
     */
    static encode(entropy) {
        return new EnglishMnemonic((0, bip39_1.entropyToMnemonic)(entropy, english_1.wordlist));
    }
    static decode(mnemonic) {
        return (0, bip39_1.mnemonicToEntropy)(mnemonic.toString(), english_1.wordlist);
    }
    static async mnemonicToSeed(mnemonic, password) {
        return await (0, bip39_1.mnemonicToSeed)(mnemonic.toString(), password);
    }
}
exports.Bip39 = Bip39;
//# sourceMappingURL=bip39.js.map